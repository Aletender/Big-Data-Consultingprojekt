\newpage
\section{Beratender Teil} \label{sec:beratender-teil}

\subsection{Essenzielle Eigenschaften bei Social Media Posts}
Social Media Posts bilden das Herzstück einer jeden Social Media Plattform.
Dabei können sich, je nach Plattform, die Social Media Beiträge merkbar unterschieden.
So setzt Instagram, als ausgewählte Social Media Plattform, ausschließlich den Schwerpunkt auf visuelle Beiträge, welche i. d. R. aus einem Foto oder (Kurz-) Video und einem Text unter dem visuellen Element bestehen.
Damit ein Beitrag auf einer Social Media Plattform gut ankommt und Klicks generiert, gibt es einige Kriterien die zu beachten sind, bzw. Eigenschaften die zu erfüllen sind.

Das erste Kriterium beschreibt die Kreativität\footcite{kaplan_users_2010} und die Einzigartigkeit\footcite{keller_building_1993} von Beiträgen.
Dabei geht es inhaltlich darum, dass besonders auffällige Beiträge, im Sinne der Authentizität, Ausgefallenheit, oder Individualität viel eher bei Benutzern der Plattform auf Interesse stoßen als Beiträge, die sich nicht von der Masse abheben.
Ein Beispiel hierfür wäre ein Restaurant für Pizza, dass mit seiner besonderen Tomatensauce visuell\footcite{green_role_2000} und schriftlich wirbt, die ggf. nach einer einzigartigen traditionellen Art und Weise hergestellt wurde.

Ein weiteres Kriterium ist die Definition einer Zielgruppe.\footcite{kotler_marketing_management}
Dies ist erheblich wichtig, da mit der Auswahl einer Zielgruppe entsprechende gewählte Artikulation notwendig ist.
Ebenso wirkt sich das auf den Stil der Beiträge aus.
Ein Pizzarestaurant, dass eher auf junge Kunden, z. B. Studenten, abzielt legt dabei visuell, als auch sprachlich andere Schwerpunkte bei den Beiträgen als ein Pizzarestaurant, dass eher auf ein gehobenes Klientel in Richtung „Fine Dining“ setzt.

Social Media Beiträge, aus Sicht eines Gastronomen, sollten immer eine Konversionsorientierung haben.\footcite{website_quality_customer_satisfaction}
Genauer gesagt definiert die Konversionsorientierung ein „call to action“ bei dem der Kunde angehalten wird auf einen Link zu klicken, ein Tisch zu re-servieren oder Sonstigem dergleichen.
Eine Strategie, die das „call to action“ Prinzip verstärkt ist eine Verlustaversion\footcite{jstor_example}, im Sinne von Marketingkampagnen, die auf ein zeitlich, oder physisch begrenztes Angebot hinweisen.
Ein Beispiel für diese Eigenschaft wäre das Bewerben eines zeitlich begrenzten Angebotes von drei Pizzen im Preis von zwei Pizzen.

Ansprechende Bildbeiträge\footcite{davidson_social_media} spiegeln ein weiteres wichtiges Kriterium wider.
So geht aus einer Studie von Sabate et al. (2014) hervor, dass visuelle Inhalte weitaus mehr Engagement erzeugen als nur rein textbasierte Beiträge.
Dabei sollten die Bilder auch aussagekräftig sein und mit der Eigenschaft der Kreativität und Einzigartigkeit synergieren.

Die persönliche und emotionale Ansprache der Zielgruppe und das Erzählen einer Geschichte sind bei dem Social Media Marketing ebenfalls wichtige Eigenschaften, die in Beiträgen beachtet werden sollten.\footcite{book}
Gemeint sind dabei Erzählungen, die Emotionen, wie z. B. Vorfreude, oder Hunger, bei Kunden wecken sollen.
Ebenso wie Erzählungen rund um das Team, die Philosophie des Restaurants oder die Besonderheit der Zutaten sind hier wichtige Aspekte in der Kommunikation mit den Kunden auf den Social Media Plattformen, um diese als Kunden zu gewinnen.

Zwei weitere Aspekte, die ebenfalls großen Einfluss auf das Social Media Marketing nehmen, sind zu einem der Ereignisbezug und zum anderen der Trendbezug.
Dabei setzen diese beiden Punkte auf Facetten, die einen Bezug auf die aktuelle Saison, wie z. B. in Form der Jahreszeiten, nehmen, oder Ereignissen die aktuell vorherrschen, wie z. B. einer Fußball Weltmeisterschaft.
Der Bezug auf solche Dinge führt generell zu einem höheren Engagement. Ein Beispiel für ein Ereignisbezug wäre die Bewerbung einer besonderen Pizza, die es nur im Zuge der Wintersaison gibt.
Ein anderes Beispiel für den Trendbezug wäre die Korrespondenz auf die Ergebnisse der deutschen Nationalmann-schaft und das aus Fußballspielsiegen Rabatte für Pizzabestellungen erfolgen.\footcite{inbook}

Eine weitere essenzielle Eigenschaft spiegelt die Social-Media-Optimierung der Inhalte wider.
Diese Eigenschaft behandelt Hashtag-Strategien, welche relevant sind für die Auffindbarkeit der Social Media Beiträge, und wie die Strukturierung der Inhalte zu erfolgen hat, um vom Social Media Algorithmus bevorzugt angezeigt zu werden.\footcite{social_media_marketing}

Darüber hinaus sollte bei jedem Social Media Beitrag die Mehrsprachigkeit und Lokalität betrachtet werden.
Beide Aspekte zielen auf ein höheres Engagement.
Durch den möglichen Einsatz von Mehrsprachigkeit, wie z. B. neben der deutschen Sprache auch noch die englische Sprache, und den Bezug auf die Lokalität, wie z. B. auf lokale Sport Events oder kulturelle Besonderheiten, kann eine höhere Zielgruppe angesprochen werden, was wiederrum zu einer höheren Nachfrage führen würde.\footcite{global_marketing_advertising}

Zusammengefasst wurden folgende Eigenschaften betrachtet und als relevant für Social Media Posts designiert: „Kreativität“, Einzigartigkeit, „Zielgruppenorientierung“, Kon-versionsorientierung“, „Bildbeiträge“, „persönliche und emotionale Ansprache“, „Story telling“, „Ereignis- und Trendbezug“, „Social-Media-Optimierung“, „Strukturierung der Posts“, „Mehrsprachigkeit“ und „Lokalität“.
Diese Eigenschaften werden als fundierte Basis für eine Entwicklung und Optimierung der Prompt des LLMs bezogen.

\subsection{Entwicklung eines Erstenwurfs für das Applikationsdesign}\label{subsec:entwicklung-eines-erstenwurfs-fuer-das-applikationsdesign}
In diesem Kapitel wird der Erstentwurf für das Applikationsdesign vorgestellt.
Der Erstentwurf beschreibt sowohl die Frontend- als auch die Backend-Architektur der Applikation.

\textbf{Frontend}
Das Frontend stellt den Interaktionsbereich für den Benutzer dar.
Entsprechend ist es wichtig, dass das Frontend übersichtlich und intuitiv gestaltet ist.
Dabei ist es entscheidend, die komplexen Zusammenhänge der Applikation und abgebildeten Prozesse so zu visualisieren, dass der Benutzer nicht überfordert wird.
Die gesamte User-Experience (UX) soll so gestaltet sein, dass der Benutzer durch die Applikation geführt und dadurch die Akzeptanz der Applikation erhöht wird.

Zusätzlich soll sich die Applikation an die Corporate Identity des Unternehmens anpassen.
Dies soll durch die Verwendung der Unternehmensfarben in der Applikation und des Logos erreicht werden.

Zur Umsetzung gilt folgendes zu beachten:
\begin{itemize}
    \item Das DISH POS typische Orange soll als primäre Farbe verwendet werden.
    \item Als sekundäre Farben sollen Grau- und Blautöne verwendet werden.
    \item Die Farben sollen so gewählt werden, dass sie die Aufmerksamkeit des Benutzers auf wichtige Elemente lenken.
    \item Unternehmens- und Applikationslogos müssen an strategischen Stellen platziert werden.
\end{itemize}

Aus den genannten Anforderungen wurden folgende Design-Elemente abgeleitet:

Landing Page

Dialog Anzeige

Post Editor

Kalender ansicht

Als technische Basis für das Frontend wird, als Ergebnis der vorangegangenen Recherche, Vue.js verwendet.
Dieses wird zum Betrieb im Kubernetes Engine Cluster bereitgestellt.
Für den Betrieb im Kubernetes Cluster muss die Software Architektur Stateless sein, um mit der Skalierung kompatibel zu sein.
Eine Stateless-Architektur bedeutet, dass die Applikation keine Zustände speichert.
Würde die Applikation Zustände speichern, müssten diese bei einer Skalierung auf mehrere Instanzen synchronisiert werden, was zu einem erhöhten Aufwand führen würde.

Um die Applikation im Kubernetes Cluster hosten zu können, erfolgt das Verpacken der Vue.js Applikation in ein Docker-Image über den Google Cloud Build Service.\footcite{google_cloud_build}

Das daraus erzeugte Docker-Image wird in den Google Kubernetes Engine Cluster genutzt und entsprechend gestartet.
Dabei wird eine Deployment-Struktur, bestehend aus einem Load Balancer Service, sowie mindestens zwei Pods erstellt.
Der Load Balancer wird für externe Zugriffe konfiguriert und leitet die Anfragen an die Pods weiter.
Der Betrieb, mit mindestens zwei Pods, gewährleistet eine hohe Verfügbarkeit der Applikation und ermöglicht eine einfache Skalierung.
In der Entwicklungsphase ermöglicht der Multi-Pod-Betrieb ein frühes Testen von Load-Balancing und Skalierung, sowie die Überprüfung der Stateless-Architektur.

Zusätzlich enthält das Deployment sowohl Konfigurations- als auch Secrets-Dateien, um die Applikation zu konfigurieren und sensible Daten zu schützen.

\textbf{Backend}
Ziel der Backend-Architektur ist es, die Datenhaltung und -verarbeitung zu gewährleisten und die benötigten Aufrufe zu anderen Komponenten zu ermöglichen.
Im Rahmen dieses Erstenwurfs wird zunächst ein einzelner Service konzipiert, der die Datenhaltung und -verarbeitung übernimmt, genannt Social Media Campaign Service (SMC Service)

Der SMC Service stellt eine REST-API bereit, welche die Kommunikation mit dem Frontend ermöglicht.
Die REST-API setzt sich aus verschiedenen Endpunkten zusammen, welche jeweils die verfügbaren Ressourcen und Aktionen beschreiben.

Folgende Ressourcen stellt der Service bereit:
\begin{itemize}
    \item \textbf{/generate-content} - POST: Dieser Endpunkt dient der generierung und Speicherung von Social Media Content.
    \item \textbf{/get-content} - GET: Dieser Endpunkt ermöglicht das Abrufen von generiertem Social Media Content.
\end{itemize}

Die implementierung des SMC Services erfolgt über das Python Framework Flask\footcite{flask}.
Zur Kommunikation mit den Google Cloud Services wird die Google Cloud Python SDK\footcite{google_cloud_sdk} verwendet.

Mithilfe der Google Cloud Python SDK und entsprechender Konfiguration des API Clients wird die Kommunikation mit den als Cloud Service gehosteten Text-to-Text- und Text-to-Image-Modellen ermöglicht.
Der POST Endpunkt wird vom Frontend aufgerufen, sobald der Benutzter seine Eingaben im Frontend abgeschlossen hat und den Content final generieren möchte.
Anschließend werden die Eingabeparameter über ein HTTP-Request-Body Objekt im JSON Format an den SMC Service gesendet.
Dieser verarbeitet den Request und routet diesen an den zuständigen POST Endpunkt.
Über den POST Endpunkt wird anschließend durch Verwendung der Google Cloud Rest-API ein weiterer HTTP-Request and den Text-to-Text-Modell Cloud Service gesendet.
Der Text-to-Text-Modell Cloud Service generiert anschließend aus den Eingaben einen finalen Eingabeprompt und sendet eine HTTP Antwort mit den Ergebnissen der Generierung als HTTP-Response-Body, welche vom SMC Service entgegengenommen und verarbeitet wird.
Der SMC Service verwendet anschließend den finalen Eingabeprompt, und tätigt zwei weitere HTTP Aufrufe, parametrisiert mit dem generierten Eingabeprompt, an den Text-to-Image-Modell Cloud Service und den Text-to-Text-Modell Cloud Service über die Google Cloud Rest-API, um die vom User geforderten Inhalte final zu generieren.
Die generierten Social Media Content Inhalte werden anschließend vom SMC Service verarbeitet, über einen HTTP Aufruf in der Datenbank gespeichert und an via HTTP Antwort auf die initiale Anfrage an das Frontend zur Visualisierung zurückgegeben.

Der GET Endpunkt wird vom Frontend aufgerufen, sobald der Benutzer über die entsprechende Funktion im Frontend die Historie der generierten Inhalte einsehen möchte.
Hierzu greift der GET- Endpunkt des SMC Services über die Google Cloud API an die konfigurierte Datenbank zu und gibt die gespeicherten Inhalte mithilfe einer Paginierungslogik an das Frontend per HTTP Antwort zurück.
Durch Ergänzung des Resource parameters kann der Benutzer zudem zwischen den verschiedenen Ressourcen, wie z. B. generierte Texte oder Bilder, wechseln.

Die Datenhaltung wird über eine Datenbank realisiert, welche innerhalb des Google Cloud Services betrieben wird.
Folgende Daten werden in der Datenbank gespeichert:
\begin{itemize}
    \item Prompts
    \item Antworten
    \item User-Feedback
    \item Generierte Bilder
    \item Sonstige Metadaten
\end{itemize}

Das Hosting des SCM Service erfolgt ebenfalls über den Google Kubernetes Engine Cluster.
Dabei ist das Kubernetes Deployment gleich aufgebaut wie das Frontend-Deployment.
Bei Bedarf können die Deployments unabhängig voneinander skaliert bzw. konfiguriert werden.

\textbf{Strategie zur Datenhaltung}

Zum Speichern der textbasierten Daten kann entschieden werden, ob Cloud Spanner\footcite{google_spanner} als relationale Datenbank oder Data Store\footcite{google_datastore} als NoSQL-Datenbank verwendet wird.

Die Untersuchung von Khan et al. zeigt, dass sich der NoSQL-Ansatz besser dazu eignet, erste Prompts und deren Antworten zu speichern.
Durch die schemalose Struktur von NoSQL-Datenbanken können neue Prompts und Antworten einfach hinzugefügt werden, ohne dass die Datenbankstruktur angepasst werden muss.
Darüber hinaus lassen sich diese Technologien gut in die Google Cloud Services integrieren.
Der Einsatz von einer relationalen Datenbank bietet sich in einem nachgelagerten Schritt an, in welchem die gesammelten Daten analysiert, strukturiert und ausgewertet werden sollen.\footcite{Khan2022SQL}

Entsprechend wird für den produktiven Einsatz des Prototypen Data Store betrachtet.
Zur lokalen Entwicklung wird entsprechend MongoDB eingesetzt, da dies der NoSQL Favorit aus der vorangegangenen Recherche ist.

\textbf{Speicherung von Bildern}

Neben den textbasierten Daten müssen auch die generierten Bilder gespeichert werden.
Dadurch wird eine effiziente Speicherung und Verwaltung der generierten Bilder gewährleistet und ein wiederverwendbarer Zugriff auf die Bilder ermöglicht.
Zur Speicherung von Bildern wird Google Cloud Storage\footcite{google_storage} verwendet.
Google Cloud Storage ist ein skalierbarer und kostengünstiger Speicher, der eine einfache Verwaltung von Bildern ermöglicht.
In diesem Service wird ein Bucket erstellt, in dem die Bilder gespeichert werden.

Die Erzeugung der Bilder wird über den Social Media Campaign Service gestartet, indem das Text-to-Image-Modell aufgerufen wird.
Das Modell generiert das Bild und schickt es an den SCM Service zurück.
Dieser speichert das Bild im Google Cloud Storage und persistiert den Pfad im Data Store.
Bei Abfragen des Bildes wird der Pfad aus dem Data Store gelesen und über die REST-API an das Frontend zurückgegeben.

Für den Prototypen wird ein einfacher Mechanismus implementiert, der die Bilder direkt im Google Cloud Storage speichert und den Pfad im Data Store persistiert.
Dabei ist zu beachten, dass die Bilder in einem öffentlichen Bucket gespeichert werden, um den Zugriff für das Frontend zu ermöglichen.
Zusätzlich ist die Auslastung des Services im produktiven Einsatz zu beachten, da die Speicherung von Bildern einen hohen Speicherbedarf verursachen kann.

Als Lösung kann die Speicherung der Bilder durch eine Sidecar-Architektur ausgelagert werden, um die Last auf den SCM Service zu reduzieren.
Dabei wird ein weiterer Service implementiert, der die Bilder entgegennimmt und im Google Cloud Storage speichert.
Dieser Service wird innerhalb des SCM Deployments gestartet und übernimmt die Speicherung der Bilder.\footcite{microsoft_sidecar_pattern}

Dadurch entsteht der Vorteil, dass eine unabhängige Auswahl der Speicherungstechnologie für die Bilder getroffen werden kann, wodurch die Performance verbessert werden kann.
Darüber hinaus teilen sich alle Pods des Deployments den gleichen Lebenszyklus, was die Wartung und Skalierung vereinfacht.\footcite{kubernetes_sidecar_containers}

Um die Bilder über einen Pfad für das Frontend verfügbar zu machen, wird ein weiterer Service, das Google Cloud Delivery Network (CDN)\footcite{google_cloud_cdn_overview}, verwendet.
Das CDN fungiert als Zwischenspeicher für statische Inhalte und stellt einen, gesondert skalierbaren, Zugriffspunkt für diese Daten bereit.
Dadurch wird sowohl die benötigte Bandbreite bei der Kommunikation mit den Applikationsservices reduziert, als auch die Ladezeiten für den Benutzer verkürzt.
Zudem reduzieren sich dadurch die Entwicklungs- und Wartungskosten, da besondere Encoding- und Skalierungsschritte entfallen.

Das CDN wird so konfiguriert, dass es auf den angelegten Bucket im Google Cloud Storage zugreift und die Bilder an den Benutzer ausliefert.
Dabei werden Synergieeffekte genutzt, da das CDN bereits in der Google Cloud integriert ist und somit eine einfache Konfiguration ermöglicht.

\subsection{Umsetzung des Applikationsdesigns in ein Prototypen}\label{subsec:umsetzung-des-applikationsdesigns-in-ein-prototypen}

\subsection{Antizipation der Kosten und des Nutzens}

Zur Berechnung der variablen Kosten im prodoktiven Betrieb der Plattform sind folgende Facetten zu betrachten.

\begin{itemize}
    \item Kosten für Generierung und Speicherung von Bildern
    \item Kosten für Generierung und Speicherung von Texten
    \item Kosten für die Speicherung von Metadaten
    \item Kosten für die Bereitstellung der REST-API
    \item Kosten für die Bereitstellung des Frontends
    \item Kosten für die Bereitstellung des Backends
    \item Kosten für die Bereitstellung des CDN
    \item Kosten für die Bereitstellung des Data Store
    \item Kosten für die Bereitstellung des Google Cloud Storage
    \item Kosten für die Bereitstellung des Kubernetes Clusters
\end{itemize}

Zusätzlich sind folgende Szenarien anzunehmen, um die Kostenstruktur zu analysieren:
Best Case Szenario: 5000 User
Worst Case Szenario: 50 User
Realistisches Szenario: 500 User

\textbf{Generierung und Speicherung von Bildern}
Zum Generieren der Bilder wird das Text-to-Image-Modell Flux 1 schnell verwendet, welches auf der Google Cloud Plattform als Endpunkt bereitgestellt wird.
Dabei wird als Maschine ein in Belgien gehostetes n1-standard-4 gewählt, welches 4 vCPUs und 15 GB RAM besitzt.
Dies ist die kleinstmögliche Konfiguration für das Modell und verursacht Kosten von 0,24 USD pro aufgewendete Maschinenstunde.\footcite{GoogleVertexAI2025}

Im Testbetrieb des Prototypen lag die Inferenzzeit pro Anfrage bei ca. 500 ms.
Basierend auf den festgelegten Szenarien ergibt sich folgende Kostenstruktur, bei der Annahme, dass jeder User 10 Anfragen pro Monat stellt:

\begin{itemize}
    \item Best Case: 5000 User * 10 Anfragen * 0,5 s * 0,24 USD = 600 USD
    \item Worst Case: 50 User * 10 Anfragen * 0,5 s * 0,24 USD = 6 USD
    \item Realistisch: 500 User * 10 Anfragen * 0,5 s * 0,24 USD = 60 USD
\end{itemize}

Die generierten Bilder werden im Google Cloud Storage gespeichert.
Dieser wird in der Region Belgien gehostet und wird mit 0,02 USD pro GB und Monat berechnet.\footcite{GoogleCloudStorage2025}

Die im Testbetrieb erzeugten Bilder hatten eine Größe von ca. 128 KB.
Basierend auf den festgelegten Szenarien ergibt sich folgende Kostenstruktur:
\begin{itemize}
    \item Best Case: 5000 User * 10 Anfragen * 128 KB * 0,02 USD = 12,8 USD
    \item Worst Case: 50 User * 10 Anfragen * 128 KB * 0,02 USD = 0,128 USD
    \item Realistisch: 500 User * 10 Anfragen * 128 KB * 0,02 USD = 1,28 USD
\end{itemize}

Der Speicherbedarf für generierte Bilder steigt neben dem eintretendem Szenario ebenso mit der Zeit an.
Dabei ist zu beachten, dass die Kosten für den Speicherplatz im Google Cloud Storage mit der Zeit steigen.

Auf die ersten drei Jahre sind dabei folgende Kosten zu erwarten:
\includegraphics{abbildungen/KostenSpeicher}

\textbf{Generierung und Speicherung von Texten}
Die Textgenerierung wird mit dem Text-to-Text-Modell Mistral 7B durchgeführt, welches ebenfalls auf der Google Cloud Plattform als Endpunkt bereitgestellt wird.
Dabei wird die gleiche Konfiguration wie beim Bildmodell verwendet, entsprechend Region Belgien und n1-standard-4 als Maschine.
Die anfallenden Maschinenstunden werden jedoch geringer angenommen, da die Inferenzzeit pro Anfrage im Testbetrieb bei ca. 100 ms lag.

Daraus ergeben sich folgende Kostenstrukturen:
\begin{itemize}
    \item Best Case: 5000 User * 10 Anfragen * 0,1 s * 0,24 USD = 120 USD
    \item Worst Case: 50 User * 10 Anfragen * 0,1 s * 0,24 USD = 1,2 USD
    \item Realistisch: 500 User * 10 Anfragen * 0,1 s * 0,24 USD = 12 USD
\end{itemize}

Zum Speichern der generierten Texte wird der Data Store verwendet.
Dieser wird in der Region Belgien gehostet und wird nach Lese- und Schreibvorgängen, sowie den gespeicherten Daten berechnet.
\includegraphics{abbildungen/kostendatastore}
\footcite{GoogleDatastorePricing2025}

Dabei wird nur die Nutzung abgerechnet, welche die Freikontingente überschreitet.
Dies wird einzig im Best Case Szenario eintreten, da die Freikontingente für die anderen Szenarien ausreichen.
Selbst im Best Case Szenario ist anzunehmen, dass einzig das Freikontingent für Schreibvorgänge minimal überschritten wird.
Dieses wird pro 100.000 Schreibvorgängen mit 0,099 USD berechnet, weshalb diese Kosten vernachlässigbar sind.

Für den Speicherbedarf ist zu beachten, dass der Text bei einem Social Media Post bei durchschnittlich 200 Zeichen liegen kann.

\begin{itemize}
    \item \textbf{Best Case}
    \begin{itemize}
        \item \textbf{2025:} \(5000 \, \text{User} \times 24 \, \text{kB} = 117,19 \, \text{MB}\)
        \item \textbf{2026:} \(117,19 \, \text{MB} + (6000 \, \text{User} \times 24 \, \text{kB}) = 263,06 \, \text{MB}\)
        \item \textbf{2027:} \(263,06 \, \text{MB} + (7200 \, \text{User} \times 24 \, \text{kB}) = 440,25 \, \text{MB}\)
    \end{itemize}

    \item \textbf{Realistic Case}
    \begin{itemize}
        \item \textbf{2025:} \(500 \, \text{User} \times 24 \, \text{kB} = 11,72 \, \text{MB}\)
        \item \textbf{2026:} \(11,72 \, \text{MB} + (600 \, \text{User} \times 24 \, \text{kB}) = 26,31 \, \text{MB}\)
        \item \textbf{2027:} \(26,31 \, \text{MB} + (720 \, \text{User} \times 24 \, \text{kB}) = 44,03 \, \text{MB}\)
    \end{itemize}

    \item \textbf{Worst Case}
    \begin{itemize}
        \item \textbf{2025:} \(50 \, \text{User} \times 24 \, \text{kB} = 1,17 \, \text{MB}\)
        \item \textbf{2026:} \(1,17 \, \text{MB} + (60 \, \text{User} \times 24 \, \text{kB}) = 2,63 \, \text{MB}\)
        \item \textbf{2027:} \(2,63 \, \text{MB} + (72 \, \text{User} \times 24 \, \text{kB}) = 4,40 \, \text{MB}\)
    \end{itemize}
\end{itemize}

Daraus ergeben sich folgende Kosten in den kommenden drei Jahren:
\includegraphics{abbildungen/Kosten_Speicher_Text}

Dabei ist über die Jahre bereits ein realisiertes Wachstum betrachtet, welches sich in den Kosten widerspiegelt.
Dennoch sind selbst im Best Case Szenario die Kosten für den Speicherplatz im Data Store vernachlässigbar.

\textbf{Plattform}
Die Plattform setzt sich aus folgenden Komponenten zusammen:
\begin{itemize}
    \item Google Kubernetes Engine Cluster
    \item Google Cloud CDN
    \item Enabler Services (Monitoring, Logging, IAM, Secret Manager)
\end{itemize}

In der Ramp-Up-Phase wird die Plattform mit einer minimalen Konfiguration betrieben.
Die Funktion der Enterprise-Version sind für die ersten drei Jahre nicht notwendig und werden daher nicht betrachtet.
Dementsprechend wird die Standardversion von der Google Kubernetes Engine verwendet, welche 0,10 USD pro Stunde kostet.\footcite{GoogleKubernetesEnginePricing2025}
Bei einem Betrieb von 24 Stunden am Tag ergeben sich folgende Kosten für die drei Jahre:

0,10 USD * 24 h * 365 Tage * 3 Jahre = 2628 USD

Zusätzlich sind die Kosten für die Enabler Services zu betrachten.

Für das Monitoring werden Kosten erhoben, basierend auf dem benötigen Speicher, sowie dem Aufrufen der erhobenen Daten.

\begin{itemize}
    \item 0,2580 USD/MiB: erste 150–100.000 USD/MiB
    \item 0,1510 USD/MiB: nächste 100.000–250.000 USD/MiB
    \item 0,0610 USD/MiB: >250.000 USD/MiB
\end{itemize}

Die Aufrufe werden mit 0,01 USD/1.000API-Leseaufruf abgerechnet, wobei API-Schreibaufrufe kostenlos sind.

Die Plattform setzt sich aus drei Kubernetes Deployments zusammen.
Diese werden mit jeweils 2 Pods betrieben, um eine hohe Verfügbarkeit zu gewährleisten.
Daraus lässt sich ein grober Bedarf an Speicher von 1 GB ableiten, welcher für die ersten drei Jahre ausreicht.
Dieser lässt sich mit unterschiedlichen Speicherzeitrahmen reduzieren.
Wenn die Monitoring-Daten für 30 Tage gespeichert werden, ergibt sich ein Speicherbedarf von ca. 84,11 MiB.
Wird dieser auf die Kostenstruktur angewendet, ergeben sich näherungsweise folgende Kosten für die drei Jahre:

0,2580 USD/MiB * 84,11 MiB * 365 Tage * 3 Jahre = 7,5 USD

Zur Vereinfachung der Berechnung werden ähnliche Kosten für das Logging angenommen.

Für die Nutzung des IAM Services fallen keine Kosten an.\footcite{GoogleIAMPricing2025}
Für den Secret Manager ist in der Standardversion eine Nutzung von 100 Secrets kostenlos, weshalb auch hier keine Kosten anfallen.\footcite{GoogleSecretManagerPricing2025}

\textbf{Personalkosten}
Für die Weiterentwicklung des Produktes werden zwei Entwickler benötigt.
Für den Betrieb des Produktes, im Sinne von Support, wird ein Service-Desk Mitarbeiter benötigt.
Die Kosten für einen Entwickler belaufen sich auf 100€ die Stunde und für einen Service-Desk Mitarbeiter auf 35€ die Stunde.


\textbf{Entwicklungskosten}
Zur Entwicklung der Plattform sind nach Abschluss dieser Arbeit noch folgende Arbeiten notwendig, um ein produktiven Betrieb zu gewährleisten:
\begin{itemize}
    \item Entwicklung und Anpassung der Frontend-Applikation
    \item Anpassen der Kubernetes Deployments
    \item Einrichten der Enabler Services
    \item Einrichten des Data Store + Google Cloud Storage
    \item Einrichten des CDN
    \item Ende-zu-Ende-Tests
    \item Aufbau Support- und Wartungsstruktur
\end{itemize}

Zur Berechnung der Entwicklungskosten sind folgende Annahmen zu treffen:
\begin{itemize}
    \item Stundensatz Entwickler: 100 Euro
    \item Entwicklungsteam: 5 Entwickler
\end{itemize}

Zur Erfassung der Aufwände werden grobe Full Time Equivalents (FTE) angenommen, welche die Entwicklungskosten für die ersten drei Jahre darstellen.
Damit ergeben sich folgende Kosten:
\begin{itemize}
    \item Entwicklung und Anpassung der Frontend-Applikation - 5 FTE
    \item Anpassen der Kubernetes Deployments - 2 FTE
    \item Einrichten der Enabler Services - 2 FTE
    \item Einrichten des Data Store + Google Cloud Storage - 1 FTE
    \item Einrichten des CDN - 1 FTE
    \item Ende-zu-Ende-Tests - 5 FTE
    \item Aufbau Support- und Wartungsstruktur 3 FTE
\end{itemize}

Daraus ergeben sich grob folgende Personalkosten:
19 FTE * 8 Stunden * 100 Euro = 15.200 Euro

Zusätzlich sind die Kosten für die Entwicklungsumgebung zu betrachten.
Diese teilt sich in das Bereitstellen des notwendigen Toolings, sowie einer Testumgebung auf.
Da die restaufwände lediglich ein kleines Team benötigen von 5 Entwicklern, fallen keine nennenswerten Kosten für die Entwicklungsumgebung an.
Einzig relevant sind die Lizenzkosten für die benötigten IDEs, welche mit 100 Euro pro Entwickler pro Monat angenommen werden.

Um die finalen Aufwände leisten zu können wird ein Zeitraum von 2 Monaten angenommen, in welchem die Entwicklung abgeschlossen wird.
Daraus ergeben sich folgende Kosten:
5 Entwickler * 100 Euro * 2 Monate = 1000 Euro

Zusammenfassend ergeben sich folgende Entwicklungskosten:
15.200 Euro + 1000 Euro = 16.200 Euro

%(Pricing Modell Auswahl)

Eine Möglichkeit die Kosten zu amortisieren könnte das Freemium-Bezahlmodell bieten, bei welchem Nutzer der Applikation erst nach einer gewissen Anzahl von Social-Media-Posts monatlich bezahlen müssen.
Die Kosten für die Premiumvariante sind so zu wählen, dass sie die Betriebskosten tragen können und eine Gewinnmarge erwirtschaftet werden kann.
Gleichzeitig muss bei der Wahl der Summe berücksichtigt werden, dass man diese nicht zu hoch ansetzt und diese in Relation zu den Wettbewerbern steht.
Kilian, die Applikation, welche auf Contentgenerierung innerhalb der Gastronomie- und Hotelbranche spezialisiert ist, nimmt mit der Premiumvariante mindestens 23€ pro Monat ein.
Die Lösung des Unternehmens MARA nimmt für seine GenAI-basierende Lösung in der Premiumvariante je Zugang 99€ pro Monat ein.
Jasper stellt sich mit zwei verschieden Varianten auf, der Startervariante mit 30€ pro Monat und der Boss-Mode-Variante mit 60€ pro Monat.
Unter der Betrachtung der Konkurrenten wird ein Einstandspreis von 20€ pro Monat bestimmt, damit diese Lösung die günstigste am Markt ist und viele Kunden anlocken kann.
Unter der Betrachtung der drei skizzierten Szenarien (50, 500, 5000 Nutzer) könnten folgende Ertragskalkulationen eintreffen:

50 Nutzer + 20€ pro Monat = 1.000€ pro Monat
500 Nutzer + 20€ pro Monat = 10.000€ pro Monat
5000 Nutzer +20€ pro Monat = 100.000€ pro Monat

%(Sonstige Einnahmen)

Ein weiterer Aspekt in der Einnahme spiegeln die erhobenen Daten, wie die Prompts und generierten Social-Media-Posts, wider.
Diese können ein Einblick in die Gastronomie vermitteln und wichtige Rückschlüsse für die Entwicklung von Produkten suggerieren.
Dementsprechend könnten diese Daten von hohem Interesse für Unternehmen sein, die ggf. selber in die Gastronomie einsteigen wollen oder Produkte für die Gastronomie entwickeln wollen.
Der Wert dieser Daten bestimmt sich im Volumen und Qualität der abgegebenen Daten.
Da sich die Applikation in den Anfängen befindet, wird der Verkauf von Nutzerdaten erstmal nicht betrachtet.

%(Break Even Analyse)
Eine Break-Even-Analyse erlaubt die Betrachtung, ab welchem Zeitpunkt sich der Betrieb der Lösung wirtschaftlich rentiert.
Die Betrachtung erfolgt auf monatlicher Basis.
Das impliziert, dass sämtliche Kosten auf einen monatlichen Faktor runtergebrochen werden, ebenso, wie die Erträge.
Daraus ergibt sich, dass die Anwendung ca. 3760 Nutzer benötigt, um den Break-Even-Point zu erreichen.

\includegraphics{abbildungen/Break_Even}